[{"content":"前不久，我的项目需要对一个 iOS 设备的系统级进程（Daemon）进行动态分析，这个进程由许多XPC活动（XPC Activities）组成。我们可以在该进程的.plist配置文件（位于 /System/Library/LaunchDaemons）内的LaunchEvents字段下找到这些 XPC 活动：\n# audioanalyticsd 为示例Daemon $ plutil -p \u0026#34;/System/Library/LaunchDaemons/com.apple.audioanalyticsd.plist\u0026#34; # ... \u0026#34;Label\u0026#34; =\u0026gt; \u0026#34;com.apple.audioanalyticsd\u0026#34; \u0026#34;LaunchEvents\u0026#34; =\u0026gt; { # 该Daemon的XPC活动 \u0026#34;com.apple.xpc.activity\u0026#34; =\u0026gt; { \u0026#34;com.apple.audioanalyticsd.assets.refresh\u0026#34; =\u0026gt; { \u0026#34;AllowBattery\u0026#34; =\u0026gt; 0 \u0026#34;GracePeriod\u0026#34; =\u0026gt; 1800 \u0026#34;Interval\u0026#34; =\u0026gt; 43200 # 运行间隔 12h = 43200s/3600s \u0026#34;Priority\u0026#34; =\u0026gt; \u0026#34;Maintenance\u0026#34; \u0026#34;Repeating\u0026#34; =\u0026gt; 1 } } } \u0026#34;ProgramArguments\u0026#34; =\u0026gt; [ 0 =\u0026gt; \u0026#34;/usr/libexec/audioanalyticsd\u0026#34; ] # ... 但这些 XPC 活动常常有定义好的运行周期，示例中为12小时，有些更长达24小时；有的 XPC 活动还需要等待系统条件满足才能运行。这导致对它们动态分析实在很困难。所以我想寻找能手动运行这些 XPC 活动的方法。\nBryce 的这篇文章给了我很多启发。他通过观察 Console 应用中的日志，发现有个叫做dasd（DuetActivitySchedulerDaemon）的进程负责决定什么时候运行什么 XPC 活动。他尝试使用调试工具 lldb 调试dasd进程：先获得_DASDaemon类实例，再调用它的方法‑[_DASDaemon forceRunActivities:]。这成功触发了对应的XPC活动！\n(lldb) e (void)[[_DASDaemon sharedInstance] forceRunActivities:@[@\u0026#34;com.apple.CacheDelete.daily\u0026#34;]] 接下来他构建了一个命令行工具，这个工具将改写后的forceRunActivities:completion:方法放在新协议中，再使用 Theos hook了XPC通信接口类NSXPCInterface，并且在_DASDaemonClient（与_DASDaemon选择器相同）加载后，经过XPC通信用新协议新方法替换掉dasd中的原协议的原方法，以调用指定XPC活动并提供反馈。\n但这个方法还是过于复杂了。我们可以用 Frida 加载脚本来hook dasd进程。\n测试：Frida 实时调用XPC活动 我们的思路很清晰：先访问_DASDaemon类的实例，再通过该实例调用‑[_DASDaemon forceRunActivities:]方法。\n首先使用 Frida 来动态调试 dasd。\nfrida -U dasd 尝试获取_DASDaemon类的实例，并将实例作为一个 Objective-C 对象。\n// 获取_DASDaemon类的实例 -\u0026gt; sharedInstance = ObjC.classes._DASDaemon.sharedInstance(); // 将实例转化为ObjC对象 -\u0026gt; sharedInstance = new ObjC.Object(sharedInstance); 获得实例后，尝试调用forceRunActivities:方法。根据Bryce在lldb中的测试，我们了解到该方法的参数是一个数组，数组中是表示「XPC活动」名称的字符串。因此，我们使用[NSString stringWithString:]方法将想启动的「XPC活动」的名称存入一个 NSString 类型的字符串，再将字符串放入一个NSArray类型的数组，作为参数传入‑[_DASDaemon forceRunActivities:]方法。注意，需要提前声明NSString和NSArray为 Objective-C 的类，否则会报错。\n// 声明ObjC的类 -\u0026gt; const { NSString, NSArray } = ObjC.classes; // 初始化ObjC字符串并赋值 -\u0026gt; const activity_string = NSString[\u0026#39;stringWithString:\u0026#39;](\u0026#39;com.apple.audioanalyticsd.assets.refresh\u0026#39;); // 初始化ObjC数组并赋值 -\u0026gt; const activity_array = NSArray.alloc().initWithObject_(activity_string); // 调用实例的方法并传参 -\u0026gt; sharedInstance.forceRunActivities_(activity_array); 在 Console 应用中，我们观察到特定的 XPC Activities 启动成功！接下来，我们把它写成一个JS脚本，以便直接加载。\n完成：Frida 脚本调用XPC活动 根据上一步的方法，我们构建了以下的JS脚本，并将调用‑[_DASDaemon forceRunActivities:]方法的行为封装进一个函数run_activity：\n// dasd_schedule_activity.js console.log(\u0026#34;reloaded script\u0026#34;); var sharedInstance = ObjC.classes._DASDaemon.sharedInstance(); sharedInstance = new ObjC.Object(sharedInstance); console.log(\u0026#34;Got DASDaemon instance: \u0026#34; + sharedInstance); function run_activity(activity_name) { const {NSString, NSArray} = ObjC.classes; const activity_string = NSString[\u0026#39;stringWithString:\u0026#39;](activity_name); const activity_array = NSArray.alloc().initWithObject_(activity_string); sharedInstance.forceRunActivities_(activity_array); console.log(\u0026#34;ran activity\u0026#34;); } console.log(\u0026#34;run_activity(\u0026#39;xpc_activity_name\u0026#39;)\u0026#34;); 使用 Frida 加载 JS 脚本，再运行run_activity函数来调用任意XPC活动：\nfrida -U dasd --load dasd_schedule_activity.js -\u0026gt; run_activity(\u0026#39;your_xpc_activity_name\u0026#39;) 完成！现在你可以按需启动 XPC 活动了。\n（特别鸣谢 Jiska）\n","permalink":"https://ro2en.me/zh/posts/xpcactivity/","summary":"前不久，我的项目需要对一个 iOS 设备的系统级进程（Daemon）进行动态分析，这个进程由许多XPC活动（XPC Activities）组成。我们可","title":"使用Frida运行XPC活动"},{"content":"为了研究的方便，理论密码学家用安全参数(Security Parameter)来量化一个密码方案的安全性，从而进行密码协议的安全性分析。\n在分析密码协议的安全性前，需要先设置一定的安全模型1，其中包括假设攻击者的计算能力。Shannon的信息论研究了攻击者在拥有无限制的计算资源条件下的安全，我们称之为信息论安全(Information-theoretic security)。它可以用统计学的观点来研究，我们用统计安全参数(statistical security parameter)来量化这种安全。\n实践中，我们通常假设攻击者的计算资源是有限的，这种安全要弱于信息论安全，我们称之为计算安全(Computational Security)。它可以用计算复杂度的观点来研究，我们用计算安全参数(computational security parameter)来量化这种安全。\n计算安全参数 计算资源有限的实体拥有概率多项式(PPT)的计算能力。一般来说，包括攻击者在内的任何实体都是PPT的。复杂度是PPT的算法可以被有效地实现，而复杂度是指数级的算法则很难被实现。我们一般认为，一个密码学方案需要满足高效性和安全性2：\n方案中各个算法的复杂度是多项式级的 破解密码方案的算法复杂度是指数级的 对于一个算法，我们用输入长度来衡量它的复杂度；那么对于一个密码学算法，我们就用计算安全参数来衡量它的复杂度。\n计算安全参数$\\kappa$是指，破解方案的算法复杂度是$O(2^{\\kappa})$。\n通过安全常数，我们就可以度量方案的高效性和安全性了：\n方案中各个算法的复杂度与计算安全参数呈多项式关系 破解方案的算法复杂度与计算安全参数呈指数级关系 我们将计算安全参数看作一个密码方案的输入长度。对称加密体制的输入长度可以看作密钥长度和明文长度；对称签名体制（哈希算法）的输入长度可以看作消息长度。而对于非对称加密体制和签名体制，密钥和消息空间是通过Setup算法生成的，输入长度可以看作是Setup算法的输入。\n在对称密码学中，方案的安全性取决于密钥或消息的保密性。在非对称密码学中，方案的安全性一般依赖于一个困难问题。各个困难问题的困难度是不一样的。比如，DDH问题就严格比CDH问题简单。计算安全参数作为非对称密码体制的输入长度，可以用来衡量不同困难问题的困难度，即破解不同困难问题的算法复杂度。一个密码协议可能拥有很多不同的密码方案，这个协议的安全性可以用总的计算安全参数来度量（最小计算复杂度）：取所有方案中最小的计算安全参数。\n在设计密码方案时，如何确定$\\kappa$的值呢？我们可以根据研究进展，确定破解某一加密体制的最佳计算复杂度，把这个复杂度的指数作为这个加密体制的计算安全参数即可。BlueKrypt维护的Keylength每年都会更新各个权威组织对于密钥长度的建议。\n实践中我们通常设置$\\kappa$ = 128。\n统计安全参数 由于密码方案是公开的，攻击者可以输入某一明文，研究在不同随机性下密文分布情况，这个过程称为模拟。如果存在某一明文和秘密值（真正的明文）的密文分布情况接近，而其他明文和秘密值的密文分布差异明显，攻击者很容易猜测这一明文就是秘密值；如果秘密值和其他任意明文的密文分布都近似，那么攻击者就无法区分哪一个是真正的秘密值了。\n我们使用统计学理论将这种近似形式化：\n我们说两个分布在统计上是接近的，是说分布之间的统计距离是一个可忽略的函数(negligeble function)3。这个函数可以用统计安全参数来表示：$O(2^{-\\sigma})$。\n统计安全参数的定义如下：\n统计安全参数$\\sigma$是指，即使拥有无限制的计算资源，攻击者成功的概率最多只有$O(2^{-\\sigma})$。\n统计安全参数的意义是，判断密码方案中任意两个输入分布在统计上“有多接近”。统计安全参数越大，可忽略函数越小，两个分布的统计距离就越近。因此，统计安全参数可以用于衡量不同方案在统计上的安全性。\n在加密方案中，对于安全性更为深层的一种理解是：从给定的密文中获得的任何关于明文的信息，都能从从独立于明文的（与密文长度相同）随机抽样字符串中获得。即一组固定长度的字符串上的均匀分布与所有可能的密文空间上的均匀分布在统计上是接近的。\n在零知识协议中，统计安全参数可以进一步细分为零知识统计安全参数和可靠(Soundness)统计安全参数。前者参数化了Transcript泄露的秘密信息，后者参数化了一个不诚实的Prover说服一个诚实的Verfier他知道一个秘密的可能性。具体参考零知识证明部分4。\n实践中我们通常设置$\\sigma$ = 40。\n邱卫东等. 密码协议基础. 高等教育出版社, 2008\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n密码体制中的安全参数k到底是个什么？ - 刘巍然-学酥的回答 - 知乎\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nDANIEL W. Computationally Secure Cryptography, 2017.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSecurity parameter, Wikipedia\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://ro2en.me/zh/posts/securitypara/","summary":"为了研究的方便，理论密码学家用安全参数(Security Parameter)来量化一个密码方案的安全性，从而进行密码协议的安全性分析。 在分析","title":"密码协议中的安全参数"}]