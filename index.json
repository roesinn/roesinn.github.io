[{"content":"A few months ago, I need to conduct dynamic analysis of a Daemon in a jailbroken iOS device, where the daemon is make up of some XPC Activities. Those XPC Activities could be found in the daemon\u0026rsquo;s configuration file (located at /System/Library/LaunchDaemons, with the .plist file extension) under the LaunchEvents field:\n# example daemon: audioanalyticsd $ plutil -p \u0026#34;/System/Library/LaunchDaemons/com.apple.audioanalyticsd.plist\u0026#34; # ... \u0026#34;Label\u0026#34; =\u0026gt; \u0026#34;com.apple.audioanalyticsd\u0026#34; \u0026#34;LaunchEvents\u0026#34; =\u0026gt; { # XPC activities \u0026#34;com.apple.xpc.activity\u0026#34; =\u0026gt; { \u0026#34;com.apple.audioanalyticsd.assets.refresh\u0026#34; =\u0026gt; { \u0026#34;AllowBattery\u0026#34; =\u0026gt; 0 \u0026#34;GracePeriod\u0026#34; =\u0026gt; 1800 \u0026#34;Interval\u0026#34; =\u0026gt; 43200 # interval 12h = 43200s/3600s \u0026#34;Priority\u0026#34; =\u0026gt; \u0026#34;Maintenance\u0026#34; \u0026#34;Repeating\u0026#34; =\u0026gt; 1 } } } \u0026#34;ProgramArguments\u0026#34; =\u0026gt; [ 0 =\u0026gt; \u0026#34;/usr/libexec/audioanalyticsd\u0026#34; ] # ... However, those XPC activities usually have pre-defined intervals for periodically running, 12 hours in the above example, and up to 24 hours in some cases; some even should wait for certain system conditions to be satisfied. Of this reason, it is hard to analyze them especially when we require to debug them on demand. So I was looking for a way to run these XPC activities manually.\nI was inspired by this article by Bryce. By investigating the logs in the Console application, he discovered that a daemon called dasd (DuetActivitySchedulerDaemon) deciding which activities to run and when to run them. He used a debug tool lldb to debug the dasd: 1) get the instance of the _DASDaemon class, 2) call its method - [_DASDaemon forceRunActivities:]. And, it successfully triggered the corresponding XPC activity!\n(lldb) e (void)[[_DASDaemon sharedInstance] forceRunActivities:@[@\u0026#34;com.apple.CacheDelete.daily\u0026#34;]] Next step, he built a command line tool which puts the rewritten forceRunActivities:completion: method in a new protocol, then uses Theos to hook the XPC communication interface class NSXPCInterface and, after _DASDaemonClient (share the same selector with _DASDaemon) is loaded, replacing the original method of the original protocol in dasd with the new method of the new protocol through XPC communication, in order to invoke the specific XPC activity and provide feedback.\nBut the method is still too much complicated. An easier path is to use Frida to hook the dasd by loading Javascript script.\nTest in Frida CLI Our idea is clear: access the instance of the _DASDaemon class, then call its -[_DASDaemon forceRunActivities:] method.\nFor the very beginning, use Frida CLI to dynamically debug dasd.\nfrida -U dasd Try to get the instance of the _DASDaemon class as an Objective-C object.\n// Get instance of _DASDaemon class -\u0026gt; sharedInstance = ObjC.classes._DASDaemon.sharedInstance(); // Convert the instance to an ObjC object -\u0026gt; sharedInstance = new ObjC.Object(sharedInstance); After obtaining the instance, try to call the forceRunActivities: method. From Bryce\u0026rsquo;s blog, we learned that the argument of the method is an array of strings, storing the XPC activity\u0026rsquo;s name. So the trick is, we use the [NSString stringWithString:] method to store the name of the targeted XPC Activity into a string of type NSString, then put the string into an array of type NSArray, which is passed as the parameter to -[_DASDaemon forceRunActivities:] method. Note that NSString and NSArray need to be declared as Objective-C classes in advance, otherwise an error will be reported.\n// declare ObjC classes -\u0026gt; const { NSString, NSArray } = ObjC.classes; // initiate an ObjC string with value -\u0026gt; const activity_string = NSString[\u0026#39;stringWithString:\u0026#39;](\u0026#39;com.apple.audioanalyticsd.assets.refresh\u0026#39;); // initiate an ObjC array with value -\u0026gt; const activity_array = NSArray.alloc().initWithObject_(activity_string); // call method of the instance -\u0026gt; sharedInstance.forceRunActivities_(activity_array); In the Console application, we observed that the specific XPC activity is launched successfully! Our next step is to write them as a JS script to be loaded directly by Frida.\nLoad JS script by Frida We built the following JS script and encapsulated the behavior of calling the -[_DASDaemon forceRunActivities:] method into a function run_activity:\n// dasd_schedule_activity.js console.log(\u0026#34;reloaded script\u0026#34;); var sharedInstance = ObjC.classes._DASDaemon.sharedInstance(); sharedInstance = new ObjC.Object(sharedInstance); console.log(\u0026#34;Got DASDaemon instance: \u0026#34; + sharedInstance); function run_activity(activity_name) { const {NSString, NSArray} = ObjC.classes; const activity_string = NSString[\u0026#39;stringWithString:\u0026#39;](activity_name); const activity_array = NSArray.alloc().initWithObject_(activity_string); sharedInstance.forceRunActivities_(activity_array); console.log(\u0026#34;ran activity\u0026#34;); } console.log(\u0026#34;run_activity(\u0026#39;xpc_activity_name\u0026#39;)\u0026#34;); Load the JS script by frida, then run the run_activity function to invoke any XPC activity:\nfrida -U dasd --load dasd_schedule_activity.js -\u0026gt; run_activity(\u0026#39;your_xpc_activity_name\u0026#39;) Done! Now you can invoke any XPC activities on demand.\n(Special thanks to Jiska)\n","permalink":"https://ro2en.me/posts/xpcactivity/","summary":"A few months ago, I need to conduct dynamic analysis of a Daemon in a jailbroken iOS device, where the daemon is make up of some XPC Activities. Those XPC Activities could be found in the daemon\u0026rsquo;s configuration file (located at /System/Library/LaunchDaemons, with the .plist file extension) under the LaunchEvents field:\n# example daemon: audioanalyticsd $ plutil -p \u0026#34;/System/Library/LaunchDaemons/com.apple.audioanalyticsd.plist\u0026#34; # ... \u0026#34;Label\u0026#34; =\u0026gt; \u0026#34;com.apple.audioanalyticsd\u0026#34; \u0026#34;LaunchEvents\u0026#34; =\u0026gt; { # XPC activities \u0026#34;com.","title":"Using Frida to trigger XPC Activities"},{"content":"For the convenience of research, theoretical cryptographers use Security Parameter to quantify the security of a cryptographic scheme and thus perform security analysis of cryptographic protocols.\nBefore analyzing the security of a cryptographic protocol, it is necessary to set up a certain security model, which includes the assumption of the attacker\u0026rsquo;s computational power. Shannon\u0026rsquo;s Information Theory investigates the security of an attacker under the condition of having unlimited computational resources, which we call Information-theoretic security. It can be studied from a statistical point of view, and we quantify this security with Statistical Security Parameter.\nIn practice, we usually assume that the attacker\u0026rsquo;s computational resources are limited, and this security is weaker than information theoretic security, which we call Computational Security. It can be studied in terms of computational complexity, and we quantify this security by the Computational Security Parameter.\nComputational Security Parameter Entities with limited computational resources have probabilistic polynomial (PPT) computational power. In general, any entity, including the attacker, is a PPT. Algorithms with a complexity of PPT can be implemented efficiently, while algorithms with a complexity of exponential are difficult to implement. We generally believe that a cryptographic scheme needs to satisfy both efficiency and security:\nthe complexity of the individual algorithms in the scheme is of polynomial order The complexity of the algorithms of the code-breaking scheme is of exponential order For an algorithm, we measure its complexity in terms of input length; then for a cryptographic algorithm, we measure its complexity in terms of computing security parameters.\nThe computational security parameter $\\kappa$ means that the algorithmic complexity of the cracking scheme is $O(2^{\\kappa})$.\nWith the safety constants, we can then measure the efficiency and safety of the scheme:\nThe complexity of the individual algorithms in the program is polynomially related to the computational safety parameter the complexity of the algorithms of the cracking scheme is exponentially related to the computational security parameter We consider the computational security parameter as the input length of a cryptographic scheme. The input length for the symmetric encryption regime can be viewed as the key length and plaintext length; the input length for the symmetric signature regime (hash algorithm) can be viewed as the message length. As for the asymmetric encryption and signature regimes, the key and message space are generated by the Setup algorithm, and the input length can be regarded as the input to the Setup algorithm.\nIn symmetric cryptography, the security of the scheme depends on the secrecy of the key or message. In asymmetric cryptography, the security of the scheme generally depends on a hard problem. The degree of difficulty varies from one difficult problem to another. For example, the DDH problem is strictly simpler than the CDH problem. Computing security parameters as input lengths to asymmetric cryptographic regimes can be used to measure the difficulty of different difficult problems, i.e., the complexity of the algorithms to crack different difficult problems. A cryptographic protocol may have many different cryptographic schemes, and the security of this protocol can be measured in terms of the total computational security parameter (minimum computational complexity): take the smallest computational security parameter among all schemes.\nHow to determine the value of $\\kappa$ when designing a cryptographic scheme? We can determine the optimal computational complexity for breaking a particular cryptographic scheme based on research progress, and use the exponent of this complexity as the computational security parameter for this cryptographic scheme.The Keylength maintained by BlueKrypt is updated annually with the recommendations of various authoritative organizations on key lengths.\nIn practice we usually set $\\kappa = 128$.\nStatistical Security Parameter Since the cipher scheme is public, the attacker can input a certain plaintext and study the distribution of the ciphertext under different randomness, a process called simulation. If there exists a certain plaintext and the secret value (the real plaintext) of the ciphertext distribution of the situation close to the other plaintext and the secret value of the ciphertext distribution of the difference is obvious, the attacker can easily guess that this plaintext is the secret value; if the secret value and the secret value and any other plaintext of the ciphertext distribution of the situation close to each other, then the attacker can not distinguish between which one is the real secret value.\nWe formalize this approximation using statistical theory:\nWhen we say that two distributions are statistically close, we mean that the statistical distance between the distributions is a negligible function (negligeble function) 1. This function can be expressed in terms of a statistical safety parameter: $O(2^{-\\sigma})$.\nThe statistical safety parameter is defined as follows:\nThe statistical security parameter $\\sigma$ means that the probability of success of an attacker is at most $O(2^{-\\sigma})$ even with unlimited computational resources.\nThe significance of the Statistical Security Parameter is to determine how statistically \u0026ldquo;close\u0026rdquo; any two input distributions in a cryptographic scheme are. The larger the statistical security parameter and the smaller the negligible function, the closer the two distributions are statistically. Therefore, the statistical security parameter can be used to measure the statistical security of different schemes.\nIn encryption schemes, a deeper understanding of security is that any information about the plaintext obtained from a given ciphertext can be obtained from a randomly sampled string of characters (of the same length as the ciphertext) that is independent of the plaintext. That is, a uniform distribution over a set of fixed-length strings is statistically close to a uniform distribution over the space of all possible ciphertexts.\nIn zero-knowledge protocols, statistical security parameters can be further subdivided into zero-knowledge statistical security parameters and reliable (Soundness) statistical security parameters. The former parameterizes the secret information leaked by Transcript, and the latter parameterizes the likelihood of a dishonest Prover convincing an honest Verifier that he knows a secret. Refer to the zero-knowledge proof section 2 for details.\nIn practice we usually set $\\sigma$ = 40.\nDANIEL W. Computationally Secure Cryptography, 2017.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\nSecurity parameter, Wikipedia.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://ro2en.me/posts/securitypara/","summary":"For the convenience of research, theoretical cryptographers use Security Parameter to quantify the security of a cryptographic scheme and thus perform security analysis of cryptographic protocols.\nBefore analyzing the security of a cryptographic protocol, it is necessary to set up a certain security model, which includes the assumption of the attacker\u0026rsquo;s computational power. Shannon\u0026rsquo;s Information Theory investigates the security of an attacker under the condition of having unlimited computational resources, which we call Information-theoretic security.","title":"Security Parameters in Cryptographic Protocols"}]